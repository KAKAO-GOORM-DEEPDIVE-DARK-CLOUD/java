# Item 42: 익명 클래스보다는 람다를 사용하라

---

## 기존 방식의 문제점

```java
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

위 코드에서 `Collections.sort()` 메서드의 두 번째 파라미터는 함수형 인터페이스이다.

> [!TIP]
>
> **함수형 인터페이스란**
>
> 단 하나의 추상메소드를 가지는 인터페이스를 함수형 인터페이스라고 한다.
>
> static, default 메서드가 여러개여도 함수형 인터페이스이다. 오직 추상 메서드가 하나여야 한다.

 

따라서 구현 객체 또는 익명 구현 객체를 전달해야한다.

과거에 따로 클래스를 선언해서 구현 객체를 전달하는 것은 번거로운 작업이니 익명 구현 객체로 전달했다.

하지만 **익명 구현 객체 전달 방식은 코드가 너무 길기 때문에** 자바는 함수형 프로그래밍에 적합하지 않았다.



## 람다의 등장

### 람다의 장점

- 람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결하다

- 자질구레한 코드들이 사라지고 어떤 동작을 하는지가 명확하게 드러난다.



```java
Collections.sort(words, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

- 여기서 람다, 매개변수(s1, s2) 에 대한 타입과 관련한 언급이 없다.

- 우리 대신 컴파일러가 문맥을 살펴 타입을 추론해준 것이다.

- 상황에 따라 컴파일러가 타입을 결정하지 못할 수도 있는데, 그럴 때는 프로그래머가 직접 명시해야 한다. 

- 타입 추론 규칙은 너무 복잡해서 이 규칙을 다 이해하는 프로그래머는 거의 없고, 잘 알지 못한다 해도 상관없다. 

- 타입을 명시해야 코드가 더 명확할 때만 예외하고는, 람다의 모든 매개변수 타입은 생략하자. 

- 그런 다음 컴파일러가 “타입을 알 수 없다”는 오류를 낼 때만 해당 타입을 명시하면 된다. 반환값이나 람다식 전체를 형변환해야 할 때도 있겠지만, 아주 드물 것이다.

- 메서드 참조 방식을 이용하여 더욱 간략하게도 가능하다.

```java
Collections.sort(words, Comparator.comparingInt(String::length));
```



### 람다의 단점

- 메서드나 클래스와 달리, 람다는 이름이 없고 문서화도 못한다.
- 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지말아야 한다.

> [!NOTE]
>
> - 람다는 한 줄일 때 가장 좋고 길어야 세 줄 안에 끝내는 게 좋다.
> - 람다가 길거나 읽기 어렵다면 더 간단히 줄여보거나 람다를 쓰지 않는 쪽으로 리팩토링 해야한다.



### 람다 사용시 주의 사항

- this의 의미가 다르다
- 람다의 this는 람다를 감싸는 클래스를 가리킨다.
- 익명 구현 객체의 this는 익명 클래스 자기 자신을 가리킨다.



---

## 핵심 요약

- 람다는 어렵지만 한 번 배워두면 매우 편해진다.

- 또한 실무에서 람다 사용은 매우 빈번하니 최대한 익숙해지자.

